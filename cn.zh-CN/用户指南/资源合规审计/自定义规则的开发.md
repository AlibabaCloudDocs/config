# 自定义规则的开发 {#concept_127405_zh .concept}

配置审计服务为您提供数十款预设规则，参见[阿里云预设规则列表](cn.zh-CN/用户指南/资源合规审计/阿里云预设规则列表.md#)。同时也支持您自定义规则函数。

自定义规则与系统预设规则的运行原理相同，区别仅在于系统预设规则是配置审计服务已经在函数计算服务中构建好了规则函数，使用时您直接在配置审计控制台选择要用的函数即可；而自定义规则需要您自己提前在函数计算服务中定义好规则函数，使用时在配置审计控制台需要录入规则函数的ARN。

通过自定义规则您可以更好的支持个性化的合规场景。

## 自定义规则的创建 {#section_e3s_mr1_g7i .section}

一共分为两个步骤，第一步是在函数计算服务创建函数，第二步是跟预设规则一样，在配置审计服务创建规则。本文重点讲解第一步，第二步请参见[创建规则](cn.zh-CN/用户指南/资源合规审计/规则管理/创建规则.md#)的说明。

要创建一个自定义规则，首先要在函数计算（FC，以下将使用FC指代函数计算）控制台创建一个FC函数。目前在函数计算服务中，支持的编程语言有Java8、Nodejs6、Nodejs8、Python2.7、Python3、PHP7.2、dotnetcore2.1。Java8和dotnetcore值支持代码包上传（包含oss上传），其他语言级支持代码包上传，也支持在线编辑。函数计算相关内容，请参考：https://help.aliyun.com/product/50980.html 。

接下来以一个规则样例为您讲解如何自定义规则。

-   规则场景：评估ECS实例是否由特定镜像启动
-   函数语言使用Python3

## 在函数计算服务中创建规则函数并在配置审计引用 {#section_tqi_kd4_tv9 .section}

函数计算创建内容，请参考：https://help.aliyun.com/product/50980.html

-   在函数计算创建规则函数后，会自动生成一个函数ARN。函数ARN可以在创建好的FC函数的概览页面中查看。

![](http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/127405/cn_zh/1565058516918/2.png)

-   在配置审计服务控制台实际引用该规则函数时，需要填入上图的ARN。

![](http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/127405/cn_zh/1565058585400/1.png)

## 规则函数的代码构建 {#section_4a0_wu4_7dm .section}

规则的本质是一段逻辑判断代码，这段代码放在刚刚创建的规则函数中。在实际的持续审计中，通过触发该规则函数的执行来实现评估。

-   以下为规则样例的示例代码。本函数代码主要有两个函数，handler为入口函数，即自定义合规触发时调用的函数。hander需在在构建FC函数时进行配置。

![](http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/127405/cn_zh/1565058779195/3.png)

-   另一个函数为put\_evaluations，在handler中调用，返回合规结果。

``` {#codeblock_uuf_9yg_04p .language-python}
#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   index.py
@Time    :   2019/07/29 18:19:00
@Author  :   wb510457
@Version :   1.0
@License :   (C)Copyright 2017-2018, Alibaba inc.
@Desc    :   None
'''

# here put the import lib
import logging
import json
from aliyunsdkcore.client import AcsClient
from aliyunsdkcore.acs_exception.exceptions import ClientException
from aliyunsdkcore.acs_exception.exceptions import ServerException
from aliyunsdkcore.request import CommonRequest

logger = logging.getLogger()

#函数处理入口
def handler(event, context):
    """
    处理函数
    :param event: 事件
    :param context: 上下文
    :return: 评估结果
    """
    # Event数据格式转换
    evt = json.loads(event)
    if not evt:
        return None

   #入参
    rule_parameters = evt.get('ruleParameters')
    #入参--镜像实例id
    image_id = rule_parameters.get(imageIds)
    #用户在fc中回调
    result_token = evt.get('resultToken')
    #函数执行参数信息
    invoking_event = evt.get('invokingEvent')

    # 初始化返回值
    compliance_type = 'NOT_APPLICABLE'
    annotation = None

    # 获取配置项
    configuration_item = invoking_event.get('configurationItem')
    if not configuration_item:
        logger.error('Configuration item is empty.')
        return None
    #进行评估
    if image_id in configuration_item
      compliance_type = 'COMPLIANCE'
    if not image_id in configuration_item
      compliance_type = 'NON_COMPLIANCE'
   #执行命令开始时间
    ordering_timestamp = configuration_item.get('captureTime')
    #资源id
    resource_id = configuration_item.get('resourceId')
    #资源类型
    resource_type = configuration_item.get('resourceType')

    # 评估结果
    evaluations = [
        {
            'complianceResourceId': resource_id,
            'complianceResourceType': resource_type,
            'orderingTimestamp': ordering_timestamp,
            'complianceType': compliance_type,
            'annotation': annotation
        }
    ]

    # 回写评估结果--评估结果数据写入
    put_evaluations(context, result_token, evaluations)
    return evaluations
#回写评估结果 -- 评估结果数据写入
def put_evaluations(context, result_token, evaluations):
    """
    回调Config Open API 回写评估结果
    :param context: 函数计算上下文
    :param result_token: 回调令牌
    :param evaluations: 评估结果
    :return: None
    """
    # 创建AcsClient实例
    client = AcsClient(
        context.credentials.access_key_id,
        context.credentials.access_key_secret,
        context.region,
    )

    # 创建request，并设置参数
    request = CommonRequest()
    request.set_domain('config.cn-hangzhou.aliyuncs.com')
    request.set_version('2018-12-24')
    request.set_action_name('PutEvaluations')
    request.add_body_params('ResultToken', result_token)
    request.add_body_params('Evaluations', evaluations)
    request.set_method('POST')

    try:
        response = client.do_action_with_exception(request)
        logger.info('PutEvaluations with request: %s, response: %s' %
                    (request, response))
    except Exception as e:
        logger.error('PutEvaluations error: %s' % e)
			
```

## 规则函数的入参 {#section_kus_h04_akx .section}

event参数。在规则函数中输入的入参信息保存在ruleParameters中，其他内容为在规则触发时自动生成事件信息。 JSON格式如下所示：

``` {#codeblock_pb3_5qd_pr5 .language-json}
{
    version:"版本号",
    orderingTimestamp:"命令执行开始时间",
    invokingEvent:{
      messageType:"消息类型",
        configurationItem：{
          "accountId":"用户id",
            "arn":"资源ARN",
            "availabilityZone":"可用区",
            "regionId":"区域id",
            "configuration":"字符串形式的资源本身配置信息,各类资源有所不同",
            "configurationDiff":"配置变更内容",
            "relationship":"关系",
            "relationshipDiff":"关系内容变更",
            "captureTime":"捕获时间",
            "resourceCreationTime":"资源创建时间",
            "resourceStatus":"资源状态",
            "resourceId":"资源ID",
      "resourceName":"资源名称"，
            "resourceType":"资源类型",
            "supplementaryConfiguration":"补充配置",
            "tags":"标签"
        },
        notificationCreationTimestamp:"事件消息生成时间"
    },
    ruleParameters：{
      "key":"value"
    },
    resultToken:"用户在FC中的回调信息" 
}
			
```

context参数。上下文信息，规则触发时自动带入

-   context.credentials.access\_key\_id:"accessKey值"
-   context.credentials.access\_key\_secret:"accessSecret值"
-   context.region:"区域信息"

以上完成自定义规则在函数计算服务的创建后，copy函数的ARN，就可以在配置审计服务继续进行规则的创建了。

